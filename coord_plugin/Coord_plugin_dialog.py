# -*- coding: utf-8 -*-
"""
/***************************************************************************
 CoordPluginDialog
                                 A QGIS plugin
 создание таблицы координат
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2022-04-13
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Платон Чекмазов
        email                : chekmazovp@icloud.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import openpyxl
import openpyxl.styles.numbers
from openpyxl.styles import Alignment
import math
import os # This is is needed in the pyqgis console also
from qgis.core import (
  QgsApplication,
  QgsDataSourceUri,
  QgsCategorizedSymbolRenderer,
  QgsClassificationRange,
  QgsPointXY,
  QgsProject,
  QgsExpression,
  QgsField,
  QgsFields,
  QgsFeature,
  QgsFeatureRequest,
  QgsFeatureRenderer,
  QgsGeometry,
  QgsGraduatedSymbolRenderer,
  QgsMarkerSymbol,
  QgsMessageLog,
  QgsRectangle,
  QgsRendererCategory,
  QgsRendererRange,
  QgsSymbol,
  QgsVectorDataProvider,
  QgsVectorLayer,
  QgsVectorFileWriter,
  QgsWkbTypes,
  QgsSpatialIndex,
  QgsVectorLayerUtils,
  QgsPoint
)

from qgis.core.additions.edit import edit

from qgis.PyQt.QtGui import (
    QColor
)

from qgis.core import (
    QgsProject,
    QgsVectorLayer,
)


from qgis.PyQt import uic
from qgis.PyQt import QtWidgets

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'Coord_plugin_dialog_base.ui'))


class CoordPluginDialog(QtWidgets.QDialog, FORM_CLASS, QtWidgets.QLabel, QtWidgets.QPushButton):
    def __init__(self, parent=None):
        """Constructor."""
        try:
            super(CoordPluginDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
            self.setupUi(self)
            self.choose_file()
            self.direct_btn.clicked.connect(self.choose_direct)
            self.act_btn.clicked.connect(self.make)
            self.layers.activated[str].connect(self.choose_layer)
            self.choose.activated[str].connect(self.id_name)
            self.directory = ''
            self.names_of_attr.activated[str].connect(self.choose_name_of_polygon)
            self.name_of_polygon.stateChanged.connect(self.nameofpolygon)
            self.flag = True
            self.flag1 = True
            self.setWindowTitle('Плагин для формирования каталога координат')
            self.id_crs.stateChanged.connect(self.nameofcrs)
            self.nameofcrs()
            self.nameofpolygon()
        except:
            pass

    def choose_file(self):
        self.layers.clear()
        list = []
        for layer in QgsProject.instance().mapLayers().values():
            if type(layer) == QgsVectorLayer:
                fetures = layer.getFeatures()
                for feature in fetures:
                    geom = feature.geometry()
                    if geom.type() == QgsWkbTypes.PolygonGeometry:
                        list.append(layer.name())
                    break
        self.layer_name = list[0]
        list = sorted(list)
        self.layers.addItems(list)
        # except:
        # self.file_btn.setText('Error')

    def choose_direct(self):
        try:
            dialog = QtWidgets.QFileDialog.getExistingDirectory(self, "/Users")
            self.direct_btn.setText(dialog)
            self.directory = dialog
        except:
            self.direct_btn.setText('Erorr')

    def make(self):
        list = []
        name = self.name.text()
        vlayer = QgsProject.instance().mapLayersByName(self.layer_name)[0]
        crs = vlayer.crs().description()
        string = ''
        for field in vlayer.fields():
            string += field.name() + field.typeName() + '\n'
        self.test.setPlainText(string)
        string = ''
        features = vlayer.getFeatures()
        self.attrs = []
        self.areas = []
        for feature in features:
            # retrieve every feature with its geometry and attributes
            string += "Feature ID: " + str(feature.id()) + '\n'
            # fetch geometry
            # show some information about the feature geometry
            geom = feature.geometry()
            geomSingleType = QgsWkbTypes.isSingleType(geom.wkbType())
            if geom.type() == QgsWkbTypes.PointGeometry:
                # the geometry type can be of single or multi type
                if geomSingleType:
                    x = geom.asPoint()
                    string += "Point: " + str(x) + '\n'
                else:
                    x = geom.asMultiPoint()
                    string += "MultiPoint: " + x + '\n'
            elif geom.type() == QgsWkbTypes.LineGeometry:
                if geomSingleType:
                    x = geom.asPolyline()
                    string += "Line: " + x + "length: " + geom.length() + "\n"
                else:
                    x = geom.asMultiPolyline()
                    string += "MultiLine: " + x + "length: " + geom.length() + "\n"
            elif geom.type() == QgsWkbTypes.PolygonGeometry:
                if geomSingleType:
                    x = geom.asPolygon()
                    self.areas.append(geom.area())
                    spis = []
                    for i in x:
                        for j in i:
                            for k in j:
                                if self.reverse.isChecked():
                                    znach = k.y(), k.x()
                                else:
                                    znach = k.x(), k.y()
                                spis.append(znach)
                    list.append(spis)
                    string += "MultiPolygon: " + str(x) + "Area: " + str(geom.area()) + "\n"
                else:
                    x = geom.asMultiPolygon()
                    self.areas.append(geom.area())
                    spis = []
                    for i in x:
                        for j in i:
                            for k in j:
                                if self.reverse.isChecked():
                                    znach = k.y(), k.x()
                                else:
                                    znach = k.x(), k.y()
                                spis.append(znach)
                    list.append(spis)
                    string += "MultiPolygon: " + str(x) + "Area: " + str(int(geom.area())) + "\n"
            # fetch attributes
            attrs = feature.attributeMap()
            attribute = []
            for k in attrs:
                attribute.append(f'{attrs[k]}')
            self.attrs.append(attribute)
            # attrs is a list. It contains all the attribute values of this feature
            self.test.setPlainText(string)
            # for this test only print the first feature
        self.test.setPlainText(string)
        self.shit = []
        a = []
        if self.id_crs.isChecked():
            if self.id_or_name == 'ID':
                crs = vlayer.crs().authid()
            else:
                crs = vlayer.crs().description()
            if crs:
                a.append(f'{crs}')
            else:
                a.append(f'Ск не определена')
        if self.square.isChecked():
            a.append(f'Площадь')
            if self.round_area.isChecked():
                a.append(str(round(sum(self.areas))) + ' кв.м')
            else:
                a.append(sum(self.areas))
                a.append('кв.м')
            self.shit.append(a)
        b = ['№ точки', 'X,м', 'Y,м']
        if self.distance.isChecked():
            b.append('Длина м')
        if self.rumb.isChecked():
            b.append('Румб')
        self.shit.append(b)
        for i in range(1, len(list) + 1):
            if self.name_of_polygon.isChecked():
                if self.round_area.isChecked():
                    self.shit.append([f'{str(self.attrs[i - 1][self.spis.index(self.nop)])}', str(round(self.areas[i - 1])) + ' кв.м'])
                else:
                    self.shit.append([f'{str(self.attrs[i - 1][self.spis.index(self.nop)])}', self.areas[i - 1],' кв.м'])
            else:
                if self.round_area.isChecked():
                    self.shit.append([f'{i} Полигон', str(round(self.areas[i - 1])) + ' кв.м'])
                else:
                    self.shit.append([f'{i} Полигон', self.areas[i - 1], ' кв.м'])
            tochki = {}
            fl = False
            k = 0
            for j in range(1, len(list[i - 1]) + 1):
                a = list[i - 1][j - 1][0]
                b = list[i - 1][j - 1][1]
                a, b = round(a, int(self.chisla.text())), round(b, int(self.chisla.text()))
                if fl:
                    d = [a, b]
                if (a, b) in tochki:
                    c = tochki[(a, b)] - k
                    k += 1
                else:
                    tochki[(a, b)] = j
                    c = j - k
                    fl = True
                if j == len(list[i - 1]) and fl:
                    self.shit.append([c] + d)
                elif j == len(list[i - 1]) and fl == False:
                    self.shit.append([1, round(list[i - 1][0][0], int(self.chisla.text())), round(list[i - 1][0][1], int(self.chisla.text()))])
                else:
                    kirieshka = [c, a, b]
                    if self.distance.isChecked():
                        fr = list[i - 1][j - 1][0] - list[i - 1][j][0]
                        sc = list[i - 1][j - 1][1] - list[i - 1][j][1]
                        res = (fr**2 + sc**2)**0.5
                        if type(res) == complex:
                            self.test.setPlainText(f'({fr}+{sc})**0.5 == {res}')
                            kirieshka.append(round(res.imag, int(self.chisla.text())))
                        else:
                            kirieshka.append(round(res, int(self.chisla.text())))
                    if self.rumb.isChecked() and j != len(list[i - 1]):
                        kirieshka.append(rumb(list[i - 1][j - 1][0], list[i - 1][j - 1][1],
                               list[i - 1][j][0], list[i - 1][j][1]))
                    self.shit.append(kirieshka)
            self.shit.append([])

        book = openpyxl.Workbook()
        sheet = book.active
        for i in self.shit:
            sheet.append(i)
        if self.chisla.text() != '0':
            for i in range(1, len(self.shit) + 1):
                sheet[f'B{i}'].number_format = '0.' + '0' * int(self.chisla.text())
                sheet[f'C{i}'].number_format = '0.' + '0' * int(self.chisla.text())
                sheet[f'D{i}'].number_format = '0.' + '0' * int(self.chisla.text())
        else:
            for i in range(1, len(self.shit) + 1):
                sheet[f'B{i}'].number_format = '0'
                sheet[f'C{i}'].number_format = '0'
                sheet[f'D{i}'].number_format = '0'
        '''self.test.setPlainText(str(self.shit))
        for i in range(1, len(self.shit) + 1):
            for j in range(len(self.shit[i])):
                sheet[i][j].value = self.shit[i][j]'''

        # format columns, set width by values. Fit values in columns
        dims = {}
        for row in sheet.rows:
            for cell in row:
                if cell.value:
                    if len(str(cell.value)) > 10:
                        cell.alignment = Alignment(wrapText=True)
                    dims[cell.column_letter] = max(
                        (dims.get(cell.column_letter, 0), len(str(cell.value))))
        for col, value in dims.items():
            sheet.column_dimensions[col].width = value + 2
        # end block

        book.save(f'{self.directory}/{name}.xlsx')
        book.close()

    def nameofpolygon(self):
        if self.flag:
            self.names_of_attr.setEnabled(True)
            vlayer = QgsProject.instance().mapLayersByName(self.layer_name)[0]
            features = vlayer.getFeatures()
            a = []
            for feature in features:
                attrs = feature.attributeMap()
                for i in attrs.keys():
                    a.append(i)
                break
            self.spis = a
            self.nop = a[0]
            self.names_of_attr.addItems(a)
            self.flag = False
        else:
            self.names_of_attr.clear()
            self.names_of_attr.setEnabled(False)
            self.flag = True

    def choose_layer(self, text):
        self.layer_name = text
        if self.flag == False:
            self.names_of_attr.setEnabled(True)
            self.names_of_attr.clear()
            vlayer = QgsProject.instance().mapLayersByName(self.layer_name)[0]
            features = vlayer.getFeatures()
            a = []
            for feature in features:
                attrs = feature.attributeMap()
                for i in attrs.keys():
                    a.append(i)
                break
            self.spis = a
            self.nop = a[0]
            self.names_of_attr.addItems(a)

    def choose_name_of_polygon(self, text):
        self.nop = text

    def nameofcrs(self):
        if self.flag1:
            self.choose.setEnabled(True)
            self.id_or_name = self.choose.currentText()
            self.flag1 = False
        else:
            self.choose.setEnabled(False)
            self.flag1 = True

    def id_name(self, text):
        self.id_or_name = text


def rumb(x1, y1, x2, y2):
    p1 = QgsPoint(x1, y1)
    p2 = QgsPoint(x2, y2)
    a = p1.azimuth(p2)
    if a <= 0:
        a += 360

    if a < 90:
        if a > 0:
            d = math.floor(a)
            c = round(a, 1)
            e = round(((c - d) * 60), 0)
            b = u'СВ ' + str(int(d)) + u'°' + str(int(e)) + u'`'

    if a == 90:
        b = 'СВ 0°0`'

    if a > 270:
        if a < 360:
            d = math.floor(360 - a)
            c = round((360 - a), 1)
            e = round(((c - d) * 60), 0)
            b = u'СЗ ' + str(int(d)) + u'°' + str(int(e)) + u'`'
        if a == 360:
            b = u'СЗ 0°0`'

    if a > 180:
        if a < 270:
            d = math.floor(270 - a)
            c = round((270 - a), 1)
            e = round(((c - d) * 60), 0)
            b = u'ЮЗ ' + str(int(d)) + u'°' + str(int(e)) + u'`'
        if a == 270:
            b = u'ЮЗ 0°0`'

    if a > 90:
        if a < 180:
            d = math.floor(180 - a)
            c = round((180 - a), 1)
            e = round(((c - d) * 60), 0)
            b = u'ЮВ ' + str(int(d)) + u'°' + str(int(e)) + u'`'
        if a == 180:
            b = u'ЮВ 0°0`'
    return b